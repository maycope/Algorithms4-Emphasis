# 3.5 应用

## 3.5.1 使用符号表的哪种实现

各符号表实现的渐进式性能总结

| 算法（数据结构）         | 最坏的情况下(N次V插入运行后) | 平均情况下(N次V插入运行后) | 关键接口                | 内存使用（字节） |
| ------------------------ | ---------------------------- | -------------------------- | ----------------------- | ---------------- |
|                          | 查找 -------插入             | 查询-------插入           |                         |                  |
| 顺序查询（无序链表）     | N ------- N     | N/2 -------N    | equals（）              | 48N              |
| 二分查找（有序数组）     | lgN -------N       | lgN ------- N/2    | compareTo（）           | 16N              |
| 二叉树查找（二叉查找数） | N  ------- N      | 1.39lgN----1.39lgN      | compareTo（）           | 64N              |
| 2-3树查找（红黑树）      | 2lgN-------2lgN        | 1.0lgN-------1.0lgN   | compareTo（）           | 64N              |
| 拉链发（链表数组）       | <lgN-------<lgN          | N/2M-------N/M    | equals（） hashCode（） | 48N+64M          |
| 线性探测法（并行数组）   | clgN -------lgN        | <1.5-------<2/5   | equals（） hashCode（） | 在132N到128N之间 |

从表中显然可以知道，对于典型的应用程序，应该在散列表和二叉查找数之间进行选择

相对二叉查找树，散列表的优点在于代码更加简单，且查找时间最优（ 常数级别，只要键的数据

类型是标准的或者简单到我们可以为它写出满足（或者近似满足）均匀性假设的高效散列函数即可）。

二叉查找树相对于散列表的优点在于抽象结构更简单（ 需要设计散列函数），红黑树可以保证最

坏情况下的性能且它能够支持的操作更多（ 排名、选择、排序和范围查找）。

因此我们的第一选择都是散列表，在其他因素更重要时候才会选择红黑树。
