# 2.4 优先队列（Prioiry Queues）

### 前言

**很多**时候，对于应用程序要求的有序数据并不要求他们都是有序的，或者说不一定要求他们在一次的排序过程中就变得全部有序，很多时候我们会收集一些数据判断当前数据中的最大值，然后再度收集一些数据，再判断当前数据中的最大值，如此这般，会有一个优先级的过程，这个优先级就是我们取出的最大值。

对于一个合格的数据结构应该支持两种操作：删除最大的元素和插入元素，这样的数据结构就叫做**优先队列**

## 2.4.1 API

优先级队列的特征在于删除最大值和插入操作，所以本节将着重介绍删除最大元素 `delMax()`,插入元素`insert()`。 按照惯例，我们将仅使用 less() 方法比较键值，就像我们一直在进行排序一样。 因此，如果记录可以有重复的键，则 maximum 表示最大键值之一。 要完成 API，我们还需要构造函数和测试是否为空操作。 为了灵活性，我们使用通用类型 Key 实现 Comparable 的通用实现。

![](http://maycope.cn/Sorting/Pirority-1.png)

## 2.4.2 初级实现

1. 数组实现（无序）：仅仅在必要的时候找出最大的元素。
2. 数组实现（有序）： 在任意时候插入列表中都保持有序，使得后续操作更加高效。
3. 链表表示方法：

![](http://maycope.cn/Sorting/Pirority-2.png)

在上述优先队列的初级实现中，**删除最大元素**和**插入元素**这两个操作之一在最坏情况下需要**线性**时间来完成。

| 数据结构 | 插入元素 | 删除最大元素 |
| :------: | :------: | :----------: |
| 有序数组 |    N     |      1       |
| 无序数组 |    1     |      N       |
|    堆    |   logN   |     logN     |
| 理想情况 |    1     |      1       |

## 2.4.3 堆的定义

数据结构`二叉堆`能够很好的实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应的，这些位置的元素有至少要大于等于数组中的另两个元素，以此类推，如果我们将所有的元素都变换成为一棵二叉树的时候，将每个较大元素和两个较小元素用边连接就可。

此时对于每个节点都要小于或等于他们的父节点这个时候对于这个堆来说就是有序的。

推出： 根节点是有序堆中最大的节点。

### 二叉堆的表示方法

如果使用指针来表示堆有序的二叉树，那么每个元素都需要**三个指针**来找到它的上下结点。

但使用完全二叉树，只需要数组而不需要指针就可以表示，十分方便。具体方法是将二叉树的结点按照**层级顺序**放入数组中。



![](http://maycope.cn/Sorting/Pirority-3.png)

**定义**：**二叉堆**（后文简称为堆）是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

![](http://maycope.cn/Sorting/Pirority-4.png)

在一个堆中，位置`k`的结点的父结点的位置为`⌊k/2⌋`，子结点位置分别为`2k`和`2k+1`。

**高性能的原因**：利用在数组中无需指针即可沿树上下移动的便利。

> 注：完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。
>
> 一棵大小为 N 的完全二叉树的高度为`⌊lgN⌋`。



## 2.4.4 堆的算法

我们在长度为 *n* + 1 的私有数组 `pq []`中表示大小为 *N* 的堆，其中`pq [0]`未使用且堆在`pq [1]`到`pq [n]中`。我们只通过函数`less()` 和`exch()`来访问元素。

**堆的有序化**：打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。

### 2.4.4.1 由下至上的堆序列化（上浮）

如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。

#### 上浮视图
![](http://maycope.cn/Sorting/Pirority-5.png)

#### 代码

```java
private void swim（int k）{
   while（k> 1 && less（k / 2，k））{
      exch（k，k / 2）;
      k = k / 2;
   }
}
```

### 2.4.4.2 由上至下的堆序列化（下沉）

如果堆的有序状态因为某个结点变得比它两个子节点或是其中之一更小了而被打破，那么我们可以通过将它和它的两个字结点中的较大值交换来修复堆。

#### 下沉视图



![](http://maycope.cn/Sorting/Pirority-6.png)



#### 代码

```java
private void sink（int k）{
   while（2 * k <= N）{
      int j = 2 * k;
      if（j <N && less（j，j + 1））j ++;
      if（！less（k，j））break;
      exch（k，j）;
      k = j;
   }
}
```

**插入元素**： 将新元素加到数组的末尾，增加堆的大小并让这个新元素上浮到合适的位置，如下图左边所示。

**删除最大元素**： 从数组的顶端删除去最大的元素并将诉诸的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。

![](http://maycope.cn/Sorting/Pirority-7.png)

这样，**删除最大元素**和**插入元素**这两个操作的用时和队列的大小仅成**对数**关系。对于一个含有 N 个元素的基于堆的优先队列，插入元素操作只需不超过 (lgN+1) 次比较，删除最大元素的操作需要不超过 2lgN 次比较。





### 基于堆的优先队列

#### 排序视图

![](http://maycope.cn/Sorting/Pirority-8-1.png)

![](http://maycope.cn/Sorting/Pirority-8-2.png)

#### 代码

```java
public class MaxPQ<Key extends Comparable<Key>> 
{
    private Key[] pq; // 基于堆的完全二叉树
 
    private int N = 0; // 存储在pq[1..N]中。 pq[0] 没有使用
 
    public MaxPQ(int maxN)
     { pq = (Key[]) new Comparable[maxN+1]; }
 
    public boolean isEmpty()
     { return N == 0; }

    public int size()
     { return N; }
 
    public void insert(Key v)
     { 
         pq[++N] = v;
         swim(N);
     }
 
    public Key delMax()
     { 
         Key max = pq[1]; // 从根节点得到最大元素.
         exch(1, N--); // 将其和最后一个结点进行交换.
         pq[N+1] = null; // 避免对象出现游离.
         sink(1); // 恢复堆的有序性.
         return max;
     }
 // 辅助方法见前面所写到的.
     private boolean less(int i, int j)
     private void exch(int i, int j)
     private void swim(int k)
     private void sink(int k) 
}
```

## 2.4.5 堆排序

我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作来将他们按顺序删去。用无序数组可以实现的优先队列在这么操作时候相当于进行一次的选择排序。基于堆的优先队列便等同与下面的一种堆排序。



#### 代码

```java
    private static void sink(Comparable[] pq, int k, int n) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && less(pq, j, j+1)) j++;
            if (!less(pq, k, j)) break;
            exch(pq, k, j);
            k = j;
        }
    }
```

以上代码使用sink() 方法将a[1]到a[N] 的元素排序。for循环构造了堆，然后while循环将最大的元素 a[1] 和 a[N] 交换并恢复了堆，如此重复知道堆变空。将 exch() 和 less() 实现中的索引减一即可得到和其他排序算法一致的实现（将 a[0] 至 a[N-1] 排序）。

### 视图

左边先进性堆的有序构建。右边进行数据的下沉排序。

![](http://maycope.cn/Sorting/Pirority-10-1.png)![](http://maycope.cn/Sorting/Pirority-10-2.png)

#### 列表分析

先进行堆的有序构建，然后进行堆的排序处理。

![](http://maycope.cn/Sorting/Pirority-9.png)


#### 2.4.5.2 下沉排序

堆排序的主要工作都是在第二阶段完成。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有的元素），但所需的比较要少很多，因为堆提供了一种从未排序部分找到最大元素的有效方法。
